---
layout: post
title: 服务器高性能程序 磁盘I/O篇
---


                                        
                                        <div><p>Linux IO<span style="font-family:宋体;">系统的架构图</span></p> <p><img src="http://www.cppblog.com/images/cppblog_com/range/21.jpg" width="326" height="433" alt="" /><br /></p> <p>&nbsp;</p> <p style="margin-left:21.0pt;text-indent:-21.0pt;"><span><span>一．</span><span style="
                                                        
                                                        
                                                        font-family:宋体;">设备</span>-------- </span><span style="font-family:宋体;">影响磁盘性能的因素</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">硬盘的转速影响硬盘的整体性能。一般情况下转速越大，性能会越好。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">硬盘的性能因素主要包括两个：1.</span><span style="font-family:宋体;">平均访问时间2</span><span style="font-family:宋体;">传输速率。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">平均访问时间包括两方面因素：</span></p> <p style="margin-left:21.0pt;"><span style="font-family:宋体;">平均寻道时间</span><span><span><span style="font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black">(Average Seek Time)</span></span></span><span><span><span style="font-family:宋体; color:black">是指硬盘的磁头移动到盘面指定磁道所需的时间</span></span></span><span style="font-family:宋体;">。一般在3ms</span><span style="font-family:宋体;">至15ms</span><span style="font-family:宋体;">之间。</span></p> <p style="margin-left:21.0pt;"><span style="font-family:宋体;">平均旋转等待时间</span><span><span style="font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:black">(Latency)</span></span><span><span style="font-family:宋体;color:black">是指磁头已处于要访问的磁道，等待所要访问的扇区旋转至磁头下方的时间。</span></span><span style="font-family:宋体;">一般在2ms</span><span style="font-family:宋体;">至6ms</span><span style="font-family:宋体;">之间。</span></p> <p style="margin-left:21.0pt;">&nbsp;</p> <p style="margin-left:21.0pt;"><span style="font-family:宋体;">传输速率(Data Transfer Rate) </span><span style="font-family:宋体;">硬盘的数据传输率是指硬盘读写数据的速度，单位为兆字节每秒（MB/s</span><span style="font-family:宋体;">）。磁盘每秒能传输80M~320M</span><span style="font-family:宋体;">字节。</span></p> <p style="margin-left:21.0pt;">&nbsp;</p> <p style="margin-left:21.0pt;"><span style="font-family:宋体;">传输速率包括内部传输速率和外部传输速率。</span></p> <p style="margin-left:21.0pt;"><span style="font-family:宋体;">内部传输率(Internal Transfer Rate) </span><span style="font-family:宋体;">也称为持续传输率(Sustained Transfer Rate)</span><span style="font-family:宋体;">，它反映了硬盘</span><a href="http://baike.baidu.com/view/266782.htm" target="_blank"><span><span style="font-family:宋体; color:windowtext;text-decoration:none;text-underline:none">缓冲区</span></span></a><span style="font-family:宋体;">未用时的性能。内部传输率主要依赖于硬盘的旋转速度。</span></p> <p style="margin-left:21.0pt;"><span style="font-family:宋体;">外部传输率（External Transfer Rate</span><span style="font-family:宋体;">）也称为</span><a href="http://baike.baidu.com/view/188732.htm" target="_blank"><span><span style="font-family:宋体; color:windowtext;text-decoration:none;text-underline:none">突发数据传输率</span></span></a><span style="font-family:宋体;">（<span>Burst Data Transfer Rate</span></span><span style="font-family:宋体;">）或接口传输率，它标称的是</span><a href="http://baike.baidu.com/view/65714.htm" target="_blank"><span><span style="font-family:宋体; color:windowtext;text-decoration:none;text-underline:none">系统总线</span></span></a><span style="font-family:宋体;">与硬盘缓冲区之间的数据传输率，外部数据传输率与</span><a href="http://baike.baidu.com/view/82486.htm" target="_blank"><span><span style="font-family:宋体; color:windowtext;text-decoration:none;text-underline:none">硬盘接口类型</span></span></a><span style="font-family:宋体;">和</span><a href="http://baike.baidu.com/view/6845.htm" target="_blank"><span><span style="font-family:宋体; color:windowtext;text-decoration:none;text-underline:none">硬盘缓存</span></span></a><span style="font-family:宋体;">的大小有关。STAT2 </span><span style="font-family:宋体;">的传输速率在300MB/s</span><span style="font-family:宋体;">级别。</span></p> <p style="margin-left:21.0pt;">&nbsp;</p> <p style="text-indent:20.25pt"><span style="font-family:宋体;">因此在硬件级上，提高磁盘性能的关键主要是降低平均访问时间。</span></p> <p style="margin-left:21.0pt;text-indent:-21.0pt;"><span><span>二．</span><span style="font-family:宋体;">设备驱动</span></span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">内存到硬盘的传输方式：poll</span><span style="font-family:宋体;">，中断，DMA</span></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>DMA</span><span style="font-family:宋体;">：当 CPU </span><span style="font-family:宋体;">初始化这个传输动作，传输动作本身是由&nbsp;DMA </span><span style="font-family:宋体;">控制器&nbsp;</span><span style="font-family:宋体;">来实行和完成。</span></p> <p style="margin-left:52.5pt; text-indent:-31.5pt;"><span>DMA</span><span style="font-family:宋体;">控制器获得总线控制权后，CPU</span><span style="font-family:宋体;">即刻挂起或只执行内部操作，由DMA</span><span style="font-family:宋体;">控制器输出读写命令，直接控制RAM</span><span style="font-family:宋体;">与I/O</span><span style="font-family:宋体;">接口进行DMA</span><span style="font-family:宋体;">传输。DMA</span><span style="font-family:宋体;">每次传送的是磁盘上相邻的扇区。Scatter-gather DMA</span><span style="font-family:宋体;">允许传送不相邻的扇区。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>CPU</span><span style="font-family:宋体;">性能与硬盘与内存的数据传输速率关系不大。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">设备驱动内有一个结构管理着IO</span><span style="font-family:宋体;">的请求队列</span></p> <p style="margin-left:21.0pt;"><span>structrequest_queue</span><span style="font-family:宋体;">（include/linux/Blkdev.h</span><span style="font-family:宋体;">）</span></p> <p style="margin-left:21.0pt;"><span style="font-family:宋体;">这里不仅仅有读写请求的数据块，还有用于IO</span><span style="font-family:宋体;">调度的回调函数结构。每次需要传输的时候，就从队列中选出一个数据块交给DMA</span><span style="font-family:宋体;">进行传输。</span></p> <p style="margin-left:21.0pt;">&nbsp;</p> <p style="margin-left:21.0pt;"><span style="font-family:宋体;">所以<a name="_GoBack">IO</a></span><span><span style="font-family:宋体;">调度的回调函数这是降低平均访问的时间</span></span><span style="font-family:宋体;">的关键。</span></p> <p>&nbsp;</p> <p style="margin-left:21.0pt;text-indent:-21.0pt;"><span><span>三．</span>OS</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>IO</span><span style="font-family:宋体;">调度器</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>Linux kernel</span><span style="font-family:宋体;">提供了四个调度器供用户选择。他们是noop,cfq,deadline,as</span><span style="font-family:宋体;">。可以在系统启动时设置内核参数elevator=&lt;name&gt;</span><span style="font-family:宋体;">来指定默认的调度器。也可以在运行时为某个块设备设置IO</span><span style="font-family:宋体;">调度程序。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">下面来简要介绍这四个调度器的电梯调度算法。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>Noop</span><span style="font-family:宋体;">：最简单的调度算法。新的请求总是被添加到队头或者队尾，然后总是从队头中选出将要被处理的请求。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>CFQ</span><span style="font-family:宋体;">：（Complete FarinessQueueing</span><span style="font-family:宋体;">）它的目标是在所有请求的进程中平均分配IO</span><span style="font-family:宋体;">的带宽。因此，它会根据进程创建自己的请求队列，然后将IO</span><span style="font-family:宋体;">请求放入相应的队列中。在使用轮转法从每个非空的队列中取出IO</span><span style="font-family:宋体;">请求。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>Deadline</span><span style="font-family:宋体;">：使用了四个队列，两个以磁盘块序号排序的读写队列，两个以最后期限时间排序的读写队列。算法首先确定下一个读写的方向，读的优先级高于写。然后检查被选方向的最后期限队列：如果最后期限时间的队列中有超时的请求，则将刚才的请求移动至队尾，然后在磁盘号排序队列中从超时请求开始处理。当处理完一个方向的请求后，在处理另一个方向的请求。（读请求的超时时间是500ms</span><span style="font-family:宋体;">，写请求的超时时间是5s</span><span style="font-family:宋体;">）</span></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>Anticipatory</span><span style="font-family:宋体;">：它是最复杂的IO</span><span style="font-family:宋体;">调度算法。和deadline</span><span style="font-family:宋体;">算法一样有四个队列。还附带了一些启发式策略。它会从当前的磁头位置后的磁盘号中选择请求。在调度了一个由P</span><span style="font-family:宋体;">进程的IO</span><span style="font-family:宋体;">请求后，会检查下一个请求，如果还是P</span><span style="font-family:宋体;">进程的请求，则立即调度，如果不是，同时预测P</span><span style="font-family:宋体;">进程很快会发出请求，则还延长大约7ms</span><span style="font-family:宋体;">的时间等待P</span><span style="font-family:宋体;">进程的IO</span><span style="font-family:宋体;">请求。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>Write/Read</span><span style="font-family:宋体;">函数</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">以ext3</span><span style="font-family:宋体;">的write</span><span style="font-family:宋体;">为例：</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">系统调用write()</span><span style="font-family:宋体;">的作用就是修改页高速缓存内的一些页的内容，如果页高速缓存内没有所要的页则分配并追加这些页。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">当脏页达到一定数量或者超时后，将脏页刷回硬盘。也可以执行相关系统调用。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">为什么要达到一定数量，是因为延迟写能在一定层度上提高系统的性能，这也使得块设备的平均读请求会多于写请求。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">在程序中调用write</span><span style="font-family:宋体;">函数，将进入系统调用f_op-&gt;write</span><span style="font-family:宋体;">。这个函数将调用ext3</span><span style="font-family:宋体;">的do_sync_write</span><span style="font-family:宋体;">。这个函数将参数封装后调用generic_file_aio_write</span><span style="font-family:宋体;">。由参数名可以看出同步写变成了异步写。如果没有标记O_DIRECT</span><span style="font-family:宋体;">，将调用函数generic_file_buffered_write</span><span style="font-family:宋体;">将写的内容写进kernel</span><span style="font-family:宋体;">的高速页缓存中。Buffer</span><span style="font-family:宋体;">是以page</span><span style="font-family:宋体;">为单位即4k</span><span style="font-family:宋体;">。之后当调用cond_resched()</span><span style="font-family:宋体;">进行进程的调度，DMA</span><span style="font-family:宋体;">会将buffer</span><span style="font-family:宋体;">中的内容写进硬盘。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">所以当每次以4k</span><span style="font-family:宋体;">为单位写入硬盘时效率会达到最高。下面是UNIX</span><span style="font-family:宋体;">环境高级编程的实验结果：</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><img src="http://www.cppblog.com/images/cppblog_com/range/22.jpg" width="471" height="598" alt="" /><br /></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">下图是linux </span><span style="font-family:宋体;">的块设备的数据操作层次：</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>Sector</span><span style="font-family:宋体;">扇区：是设备驱动和IO</span><span style="font-family:宋体;">调度程序处理数据粒度。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>Block</span><span style="font-family:宋体;">块：是VFS</span><span style="font-family:宋体;">和文件系统处理数据的粒度。其大小不唯一，可以是512,1024,2048,4096</span><span style="font-family:宋体;">字节。内核操作的块大小是4096</span><span style="font-family:宋体;">字节。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>Segment</span><span style="font-family:宋体;">段：是DMA</span><span style="font-family:宋体;">传送的单位。每一个段包含了相邻的扇区，它能使DMA</span><span style="font-family:宋体;">传送不相邻的扇区。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><img src="http://www.cppblog.com/images/cppblog_com/range/23.jpg" width="359" height="353" alt="" /><br /></p> <p>&nbsp;</p> <p style="margin-left:21.0pt;text-indent:-21.0pt;"><span><span>四．</span><span style="font-family:宋体;">用户程序</span></span></p> <p style="margin-left:21.0pt"><span style="font-family:宋体;">根据以上的分析，我们的<span>write buffer</span></span><span style="font-family:宋体;">一般设置为4K</span><span style="font-family:宋体;">的倍数。</span></p> <p style="margin-left:21.0pt">&nbsp;</p> <p style="margin-left:21.0pt"><span style="font-family:宋体;">在程序中有意识的延迟写。这个是os</span><span style="font-family:宋体;">的策略，当然也可以应用到程序的设计中。当然也会有缺点：1.</span><span style="font-family:宋体;">如果硬件错误或掉电，则会丢失内容（做额外的备份）2.</span><span style="font-family:宋体;">需要额外的内存空间。（牺牲内存来提高IO</span><span style="font-family:宋体;">的效率）</span></p> <p style="margin-left:21.0pt">&nbsp;</p> <p style="margin-left:21.0pt"><span style="font-family:宋体;">我们还需根据系统的IO</span><span style="font-family:宋体;">调度器的调度策略，设计出不同的IO</span><span style="font-family:宋体;">策略。尽量降低磁盘的平均访问时间，降低请求队列，提高数据传输的速率。</span></p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p> <p style="margin-left:21.0pt;text-indent:-21.0pt;"><span><span>五．</span><span style="font-family:宋体;">监控硬盘的工具和指标</span></span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>Iostat&#8211;x &#8211;k 1</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>&nbsp;-x</span><span style="font-family:宋体;">显示更多的消息&nbsp;-k</span><span style="font-family:宋体;">数据以KB</span><span style="font-family:宋体;">为单位 1</span><span style="font-family:宋体;">每秒显示一次</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">输出显示的信息</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>Iowait</span><span style="font-family:宋体;">：cpu</span><span style="font-family:宋体;">等待未完成的IO</span><span style="font-family:宋体;">请求而空闲的时间的比例。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>Idle</span><span style="font-family:宋体;">：cpu</span><span style="font-family:宋体;">空闲且无IO</span><span style="font-family:宋体;">请求的比例。</span></p> <p style="margin-left:31.5pt; text-indent:-10.5pt;"><span>rrqm/s</span><span style="font-family:宋体;">：每秒这个设备相关的读取请求有多少被Merge</span><span style="font-family:宋体;">了。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>wrqm/s</span><span style="font-family:宋体;">：每秒这个设备相关的写入请求有多少被Merge</span><span style="font-family:宋体;">了。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>rsec/s</span><span style="font-family:宋体;">：每秒读取的扇区数；</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>wsec/</span><span style="font-family:宋体;">：每秒写入的扇区数。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>r/s</span><span style="font-family:宋体;">：每秒完成的读 I/O </span><span style="font-family:宋体;">设备次数。即<span> delta(rio)/s</span></span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>w/s</span><span style="font-family:宋体;">：每秒完成的写 I/O </span><span style="font-family:宋体;">设备次数。即<span> delta(wio)/s</span></span></p> <p style="margin-left:31.5pt; text-indent:-10.5pt;"><span>await</span><span style="font-family:宋体;">：每一个IO</span><span style="font-family:宋体;">请求的处理的平均时间（单位是毫秒）。包括加入请求队列和服务的时间。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>svctm:&nbsp;&nbsp; </span><span style="font-family:宋体;">平均每次设备I/O</span><span style="font-family:宋体;">操作的服务时间。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>avgrq-sz: </span><span style="font-family:宋体;">平均每次设备I/O</span><span style="font-family:宋体;">操作的数据大小 (</span><span style="font-family:宋体;">扇区)</span><span style="font-family:宋体;">。即<span> delta(rsect+wsect)/delta(rio+wio)<br /> avgqu-sz: </span></span><span style="font-family:宋体;">平均I/O</span><span style="font-family:宋体;">队列长度。即 delta(aveq)/s/1000 (</span><span style="font-family:宋体;">因为aveq</span><span><span style="font-family:宋体;color:#333333">的单位为毫秒</span></span><span><span style="font-family:&quot;Arial&quot;,&quot;sans-serif&quot;;color:#333333">)</span></span><span><span style="font-family:宋体;color:#333333">。</span></span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>%util</span><span style="font-family:宋体;">：在统计时间内所有处理IO</span><span style="font-family:宋体;">时间，除以总共统计时间。例如，如果统计间隔1</span><span style="font-family:宋体;">秒，该设备有0.8</span><span style="font-family:宋体;">秒在处理IO</span><span style="font-family:宋体;">，而0.2</span><span style="font-family:宋体;">秒闲置，那么该设备的%util = 0.8/1 = 80%</span><span style="font-family:宋体;">，所以该参数暗示了设备的繁忙程度。一般地，如果该参数是100%</span><span style="font-family:宋体;">表示设备已经接近满负荷运行了（当然如果是多磁盘，即使%util</span><span style="font-family:宋体;">是100%</span><span style="font-family:宋体;">，因为磁盘的并发能力，所以磁盘使用未必就到了瓶颈）。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">下面我们做一个实验来分析一下</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">我们使用命令</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span><span>time dd if=/dev/zero of=/home/zhouyuan/mytest bs=1M count=3000</span></span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">向mytest</span><span style="font-family:宋体;">写入数据，写入3G</span><span style="font-family:宋体;">。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">截取部分的状态监控：</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><img src="http://www.cppblog.com/images/cppblog_com/range/24.jpg" width="992" height="354" alt="" /><br /></p> <p style="margin-left:21.0pt;text-indent:0cm;"><img src="http://www.cppblog.com/images/cppblog_com/range/25.jpg" width="692" height="361" alt="" /><br /></p> <p style="margin-left:21.0pt;text-indent:0cm;"><img src="http://www.cppblog.com/images/cppblog_com/range/26.jpg" width="668" height="357" alt="" /><br /></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">如图2</span><span style="font-family:宋体;">，当两条数据<span> iowait </span></span><span><span style="font-family: 宋体;">达到了</span> 99% </span><span style="font-family:宋体;">以上，写入的数据是0</span><span style="font-family:宋体;">，这是因为DMA</span><span style="font-family:宋体;">将内存的中的数据传输给设备。结合图1</span><span style="font-family:宋体;">的前两条数据，利用率达到了99%+</span><span style="font-family:宋体;">却没有写入的磁盘块。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">如图3</span><span style="font-family:宋体;">，iowait</span><span style="font-family:宋体;">下降，说明cpu</span><span style="font-family:宋体;">开始执行相关程序，而此时块设备开始写入的数据。这两个操作是异步进行的。</span></p> <p style="margin-left:21.0pt;text-indent:0cm;">&nbsp;</p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>Vmstat&#8211;k &#8211;n 1</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>Swap</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">　　si: </span><span style="font-family:宋体;">从磁盘交换到内存的交换页数量，单位：KB/</span><span style="font-family:宋体;">秒</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">　　so: </span><span style="font-family:宋体;">从内存交换到磁盘的交换页数量，单位：KB/</span><span style="font-family:宋体;">秒</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span>IO</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">　　bi: 从</span><span style="font-family:宋体;">块设备接受的块数，单位：块/</span><span style="font-family:宋体;">秒</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><span style="font-family:宋体;">　　bo: </span><span style="font-family:宋体;">发送到块设备的块数，单位：块/</span><span style="font-family:宋体;">秒</span></p> <p style="margin-left:21.0pt;text-indent:0cm;"><img src="http://www.cppblog.com/images/cppblog_com/range/27.jpg" width="748" height="31" alt="" /><br /></p> <p style="margin-left:21.0pt;text-indent:0cm;"><img src="http://www.cppblog.com/images/cppblog_com/range/28.jpg" width="736" height="461" alt="" /><br /></p> <p style="margin-left: 21pt; text-indent: 0cm; "><span style="font-family: 宋体; ">从图中我们可以看出系统的延迟写。</span></p></div><img src ="http://www.cppblog.com/range/aggbug/154449.html" width = "1" height = "1" /><br><br><div align=right><a style="text-decoration:none;" href="http://www.cppblog.com/range/" target="_blank">Range</a> 2011-08-26 20:04 <a href="http://www.cppblog.com/range/archive/2011/08/26/154449.html#Feedback" target="_blank" style="text-decoration:none;">发表评论</a></div>
                                                
                                            
