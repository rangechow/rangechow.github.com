---
layout: post
title: '函数调用原理'
tags: 计算机基础
---


1.   栈的基本概念

在计算机科学中，栈（stack）是一种特殊的串行形式的数据结构，它的特殊之处在于只能允许在链结串行或阵列的一端进行加入资料和输出资料的运算，按照后进先出（LIFO）的原理运作。
可操作的一端称为栈顶（top），栈顶可指向栈的第一个元素或者第一个元素的前的空地址，这依赖于栈的实现，在x86_64的机器上栈顶指向第一个元素。
不可操作的一端称为栈底，栈底是栈开始的地址。添加数据的操作称为`push`，删除数据的操作称为`pop`，这是栈最重要的两个操作。
高级语言（high-level language）一个重要的特点是引入了过程（procedure）和函数（function）。
函数的观点类似于跳转，即一个函数结束时会将控制权交回调用它的函数。这个特点的高级抽象就是后进先出，因此它的实现需要借助栈。
进程为了实现函数，在地址空间中专门开辟了一块栈段。进程地址空间大致被分为三个区域：代码段、数据段，堆栈段。这三个段区依次由低地址向高地址排布（x86_64的机器）。如下图：

<center>
![]({{site.baseurl}}/img/20160901-1.png "进程的地址空间")
</center>

虽然进程的地址空间是从低地址向高地址排布，但是栈段是从高地址向低地址生长的（这一点很重要），即栈底为高地址，栈顶为低地址。
 
2.   程序的栈帧

函数调用栈（call stack）是使用栈数据结构保存进程中函数调用信息。函数调用栈位于进程地址空间的堆栈段。每个正在运行的函数在堆栈段都有自己的栈帧，栈帧的排布根据函数的调用关系后进先出，如下图。
 
<center>
![]({{site.baseurl}}/img/20160901-2.png "程序的栈帧")
</center>

一个挂起函数的栈帧包括调用函数（也是上一个栈帧）的栈底地址、局部变量、被保存的寄存器、临时变量、调用下一个函数的参数、返回地址。
 
<center>
![]({{site.baseurl}}/img/20160901-3.png "单个函数的栈帧")
</center>

3.   切换过程

在x86_64机器上，使用两个寄存器标记当前函数的栈帧， rbp和rsp。rbp称为基址寄存器，标记当前栈帧的栈底，rsp可称为栈寄存器，标记当前栈帧的栈顶。栈帧的切换，也是函数调用的过程就是围绕这两个寄存器实现的。
当函数foo调用bar时，1）在新的栈帧中保存旧栈帧的栈底地址，2）将新栈帧的栈底地址保存到rbp中。
 
<center>
![]({{site.baseurl}}/img/20160901-4.png "新建栈帧流程")
</center>

这个过程是通过下面的汇编代码实现的。
 
<center>
![]({{site.baseurl}}/img/20160901-5.png "新建栈帧汇编代码")
</center>

当函数bar返回foo时，3）栈顶指针指向栈底，4）将旧栈底的地址保存到%ebp中。

<center>
![]({{site.baseurl}}/img/20160901-6.png "恢复栈帧流程")
</center>

这个过程是通过leave指令实现的，它等价于下面的汇编代码。

<center>
![]({{site.baseurl}}/img/20160901-7.png "恢复栈帧汇编代码")
</center>

函数调用涉及到过程的转移，支持过程转移的汇编指令主要是call和ret。
Call指令有一个目标操作数，即被调用过程的起始的指令地址。Call指令的效果是将返回地址入栈，并跳转到被调函数的起始处。返回地址是在程序中call指令后面的那条指令地址，当被调函数返回时，控制流会从这个地址继续执行。
Ret指令从栈中弹出返回地址，并跳转到这个位置继续执行，此时被调函数结束。
 
4.   实例演示

现在实现一个程序，在foo函数中调用bar函数，使用GDB来观察真实的栈帧切换和函数的栈帧。
foo函数：

<center>
![]({{site.baseurl}}/img/20160901-8.png "foo函数代码") 
</center>

bar函数：

<center>
![]({{site.baseurl}}/img/20160901-9.png "bar函数代码")
</center>

在foo函数中，调用bar函数的指令callq指向的地址正是bar函数的起始地址0x400494。另一个需要注意的地址是函数调用的返回地址0x4004c6。在foo调用bar后，在foo的栈帧中可以看到这个地址。
foo函数的callq将控制流从foo转移到bar函数和bar函数的retq将控制流从bar函数交回给foo函数。foo函数和bar函数的前两个指令和倒数第二个指令相同，分别是建帧和恢复帧的指令。
foo函数的第三条指令是预分配局部变量指令，会统一预留16字节的空间，此时修改了rsp的值，然后开始分配局部变量的空间。但是在bar函数中并没有这条指令，因为bar函数是最后调用的简单函数，没有使用rsp。
我们在16行和10行加上断点，运行程序。

<center>
![]({{site.baseurl}}/img/20160901-10.png "断点运行") 
</center>

程序在第16行暂停，此时程序在执行foo函数，我们查看rbp和rsp的内容，它们指向的是foo的栈帧，并验证栈是从高地址向低地址生长的。

<center>
![]({{site.baseurl}}/img/20160901-11.png "foo的栈信息") 
</center>

然后让程序继续运行，程序在第10行停止，此时程序在执行bar函数，我们查看rbp和rsp的内容。
 
 <center>
![]({{site.baseurl}}/img/20160901-12.png "bar的栈信息") 
</center>

rbp和rsp的值已经更新，指向了bar的栈帧。我们查看当前的内存，

<center>
![]({{site.baseurl}}/img/20160901-13.png "内存中的内容")
</center>

bar栈帧的rbp指向的地址内保存的是foo栈帧的rbp地址，内存块1的值是地址3的值。我们可以计算出当前foo的栈帧地址为0x7fffffffe4d0 – 0x7fffffffe4c8。内存块2的值即为调用返回的指令地址。
在第17行加上断点查看bar返回后rbp和rsp的值。

<center>
![]({{site.baseurl}}/img/20160901-14.png "恢复foo栈帧后的栈信息")
</center>

rbp和rsp的值和调用前一样了。
 
5.   小恶作剧

既然知道了函数栈帧的原理，我们可以通过修改返回地址，实现最简单的栈溢出例子。

<center>
![]({{site.baseurl}}/img/20160901-15.png "栈溢出例子")
</center>

通过第一个局部变量，我们可以找到返回地址的位置，然后修改返回地址的值，程序将将跳过x=1这行，直接打印出x等于0。

<center>
![]({{site.baseurl}}/img/20160901-16.png "偏移计算") 
</center>
	

*本文使用的gcc版本为4.4.5 20110214 (Red Hat 4.4.5-6)，编译时没有使用优化选项。*

*参考文献：*

*1.	https://en.wikipedia.org/wiki/Stack_(abstract_data_type)*

*2.	《深入理解计算机系统》*

*3.	< Smashing The Stack For Fun And Profit>*

*4.	http://www.cnblogs.com/bangerlee/archive/2012/05/22/2508772.html*

*5.	http://blog.chinaunix.net/uid-23069658-id-3981406.html*

