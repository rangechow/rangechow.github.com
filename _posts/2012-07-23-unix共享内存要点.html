---
layout: post
title: unix共享内存要点
---


                
                <br />共享内存优点：1.在进程之间不通过内核传递数据，即不通过系统调用拷贝数据，达到快速，高效的数据传输。<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2.随内核持续<br />*nix的共享内存有两套API：Posix和System
                
                
                V<br /><br />两者的主要差别是共享内存的大小<br />1.Posix共享内存大小可通过函数ftruncate随时修改<br />2.System V共享内存大小在创建时就已经确定，而且最大值根据系统有所不同<br /><br />&nbsp;Posix共享内存&nbsp;<br />&nbsp; &nbsp; #include &lt;sys/mman.h&gt; &nbsp;（mmap，munmap，msync，shm_open，shm_unlink）<br /><br />最主要的函数 &nbsp;-- mmap<br />&nbsp; &nbsp; &nbsp;void* mmap(void* addr,size_t len,int prot,int flags,int fd,off_t offset)<br />&nbsp; &nbsp; &nbsp;函数将一个句柄映射到内存中，这个句柄可以是open的文件句柄，也可以是shm_open的共享内存区对象。当fd=-1时为匿名共享内存。<br />&nbsp; &nbsp; &nbsp;*nix一切皆文件的观点，shm_open也是在/dev/shm目录下创建一个文件对象，返回对象的描述符。<br />&nbsp; &nbsp; &nbsp;mmap将句柄作为共享内存的底层支撑对象，映射到内存中，这样可以不通过read、write在进程之间共享内存。由此推测一下，在*nix的进程间传递数据更加原始的方法是进程间读写一个文件。但是频繁的open、read、write、lseek系统调用会消耗过多的计算资源。所以想到了将这个文件句柄映射到内存中，这样就提高了进程间传递数据的效率。<br /><br />需要注意的函数 -- msync<br />&nbsp; &nbsp; &nbsp; 当修改了内存映射区的内存后，内核会在某个时刻将文件的内容更新。为了确信文件被更新，调用函数msync。文件的更新可以是同步（MS_SYNC）也可以是异步（MS_ASYNC）。（估计这里也是调用了函数write更新文件）<br /><br />System V共享内存<br />&nbsp; &nbsp; #include &lt;sys/shm.h&gt; &nbsp;(shmget,shmat,shmdt,shmctl)<br />由于System V的共享内存有大小的限制，所以可考虑，使用共享内存数组来解决这个问。虽然数组的大小即一个进程可以获取共享内存的数量也是有限制，但是可以缓解System V单个共享内存过小的问题。<img src ="http://www.cppblog.com/range/aggbug/184665.html" width = "1" height = "1" /><br><br><div align=right><a style="text-decoration:none;" href="http://www.cppblog.com/range/" target="_blank">Range</a> 2012-07-23 00:08 <a href="http://www.cppblog.com/range/archive/2012/07/23/184665.html#Feedback" target="_blank" style="text-decoration:none;">发表评论</a></div>
                        
                    
