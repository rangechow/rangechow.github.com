---
layout: post
title: 'Linux2.26软定时器的设计'
tags: 服务端技术
---

上两篇文章介绍了Linux2.26中的计时架构，包括底层硬件和软件的基本模块。
这一篇文章要说的是软定时器。
为什么要加一个软字呢？
这需要区别与前两篇文章介绍硬件定时器。
我们知道硬件定时器发起定时中断，调用timer_interrupt()函数，更新jiffies，上墙时间，CPU资源等。

软定时器通过软件程序实现，允许函数在未来的某个时刻调用。
所以软定时器的基本原理相当简单。
软定时器有一个expire字段，值为当前jiffies加上一定数额的ticks。
之后，每次检查软定时器，用当前jiffies与这个字段的值对比。
如果当前jiffies大于或者等于expire，则这个定时器到期，调用相关回调函数。

即软定时器的数据结构：

    struct timer_list {
        struct list_head entry;
        unsigned long expires;
        spinlock_t lock;
        unsigned long magic;
        void (*function)(unsigned long);
        unsigned long data;
        tvec_base_t *base; 
    }
  
由于软定时器是以jiffies为时间标准，即精度为1ms。

软定时器间是用list组织，但是如果只用一个list组织软定时器，检查软定时器遍历整个list就非常耗时。
因此这里用了多级hash list，即时间轮，来组织整个软定时器。

软定时器管理器（时间轮）结构

    typedef struct tvec_t_base_s {
        spinlock_t lock;
        unsigned long timer_jiffies;
        struct timer_list *running_timer;
        tvec_root_t tv1;
        tvec_t tv2;
        tvec_t tv3;
        tvec_t tv4;
        tvec_t tv5;
    } tvec_base_t;

tv1是一个256个节点的list，在tv1中的定时器在接下来的255(2^8-1)个tick将会逐一到期。
tv2、tv3、tv4是64个节点的list，到期节点分别是(2^14)-1,(2^20)-1,(2^26)-1。
tv5只有一个节点，存储到期时间大于(2^26)-1的定时器。
timer_jiffies指示最早的一个已到期还未被检查的定时器。
如果timer_jiffies和jiffies一致则表示没有被积压的定时器。
如果timer_jiffies小于jiffies则表示还有未处理的定时器。
需要注意的是，jiffies是异步更新,在检查定时器的过程中，全局jiffies仍在不断的增加。
由于延迟处理函数处理时间轮需要较长的时间,导致timer_jiffies可能远远小于jiffies。

虽然时间轮是一个非常好的用来处理定时器的数据结构，但是处理定时器是一个非常耗时耗性能的操作。
在linux2.6中，定时器处理函数run_timer_softirq()由软中断TIMER_SOFTIRQ激活，

检查软定时器是通过一个延迟函数，这个函数在激活后会执行一段时间。
因此，一般无法保证定时器的回调函数在指定的时刻被执行。
软定时器只能保证在到期后的一个短暂延迟范围内执行回调函数。
所有，如果是严格的实时程序，需要用其他方法来保证更高精度的定时器。
